{"ast":null,"code":"import { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, createVNode as _createVNode, createCommentVNode as _createCommentVNode, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, createBlock as _createBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"v-catalog\"\n};\nconst _hoisted_2 = {\n  class: \"v-catalog_link\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_router_link = _resolveComponent(\"router-link\");\n  const _component_VCatalogItem = _resolveComponent(\"VCatalogItem\");\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createVNode(_component_router_link, {\n    to: {\n      name: 'cart',\n      params: {\n        cart_data: _ctx.CART\n      }\n    }\n  }, {\n    default: _withCtx(() => [_createElementVNode(\"div\", _hoisted_2, \"Cart: \" + _toDisplayString(_ctx.CART.length), 1 /* TEXT */)]),\n\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"to\"]), _createCommentVNode(\" циклом по массиву в key уникальное знаечение(не может быть 2-х ключей с одинаковыми значениями) \"), _createCommentVNode(\" :product_data=\\\"product\\\" мы связываем product_data дочернего эл та с product родительского  \"), _createCommentVNode(\" на каждой итерации  создает отдельный новый компонент\\n    VCatalogItem и в его данные засовывает каждый новый объект чтолежит  в массиве  products \"), _createCommentVNode(\" @sendArticle=\\\"showArticle\\\"- так происзодит связывание того что передает ребенок родителю  \"), _createCommentVNode(\" т.е при нажатии на кнопку в ребенке в функции showArticle я описал что делать в родителе \"), _createCommentVNode(\" v-for=\\\"product in this.$store.state.products\\\" заменил на PRODUCTS в computed \"), (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.PRODUCTS, product => {\n    return _openBlock(), _createBlock(_component_VCatalogItem, {\n      key: product.article,\n      product_data: product,\n      onAddToCart: $options.addToCart\n    }, null, 8 /* PROPS */, [\"product_data\", \"onAddToCart\"]);\n  }), 128 /* KEYED_FRAGMENT */))]);\n}","map":{"version":3,"names":["class","_createElementBlock","_hoisted_1","_createVNode","_component_router_link","to","name","params","cart_data","_ctx","CART","_createElementVNode","_hoisted_2","_toDisplayString","length","_createCommentVNode","_Fragment","_renderList","PRODUCTS","product","_createBlock","_component_VCatalogItem","key","article","product_data","onAddToCart","$options","addToCart"],"sources":["/home/denis/Desktop/catalog/catalog-vue-js/src/components/v-catalog.vue"],"sourcesContent":["<template>\n    <div class=\"v-catalog\">\n    <router-link :to=\"{name:'cart',params:{cart_data:CART}}\" >\n    <div class=\"v-catalog_link\">Cart: {{ CART.length }}</div>\n    </router-link>\n    <!-- циклом по массиву в key уникальное знаечение(не может быть 2-х ключей с одинаковыми значениями) -->\n    <!-- :product_data=\"product\" мы связываем product_data дочернего эл та с product родительского  -->\n   <!-- на каждой итерации  создает отдельный новый компонент\n    VCatalogItem и в его данные засовывает каждый новый объект чтолежит  в массиве  products -->\n    <!-- @sendArticle=\"showArticle\"- так происзодит связывание того что передает ребенок родителю  -->\n<!-- т.е при нажатии на кнопку в ребенке в функции showArticle я описал что делать в родителе -->\n<!-- v-for=\"product in this.$store.state.products\" заменил на PRODUCTS в computed -->\n  <VCatalogItem\n    v-for=\"product in PRODUCTS\"\n    :key=\"product.article\"\n    :product_data=\"product\" \n    @addToCart=\"addToCart\"\n    />\n    </div>\n</template>\n<script>\nimport VCatalogItem from './v-catalog-item.vue';\nimport{mapActions,mapGetters} from 'vuex';\nexport default {\n    name: \"v-catalog\",\n    computed: {\n        ...mapGetters([\n            'PRODUCTS',\n            'CART'\n    ])\n    },\n    methods:{\n    ...mapActions(['GET_PRODUCTS_FROM_API','ADD_TO_CART']),//  это сделано для простоты обращения к методу GET_PRODUCTS_FROM_API \n    addToCart(data){\nthis.ADD_TO_CART(data)\n}\n    },\n    mounted(){ //  когда отрендорился весь хтмл будет выполняться то что написано тут \n        this.GET_PRODUCTS_FROM_API()\n        .then((response)=>{// проверка на полученные данные, если данные пришли то выведет в консоль \n            if(response){\n                console.log(\"данные получены\")\n            }\n        })\n\n    },\n    data() {\n        return {}\n\n},\ncomponents: { VCatalogItem }\n        }\n\n</script>\n<style lang=\"scss\">\n.v-catalog{\n    \n        display: flex;\n        flex-wrap: wrap;\n        justify-content: space-between;\n        align-items: center;\n        .v-catalog_link{\n            position: absolute;\n            top:10px;\n            right: 10px;\n            padding: 16px;\n            border: solid 1px gray;\n        }\n\n}\n</style>"],"mappings":";;EACSA,KAAK,EAAC;AAAW;;EAEjBA,KAAK,EAAC;AAAgB;;;;uBAF3BC,mBAAA,CAiBM,OAjBNC,UAiBM,GAhBNC,YAAA,CAEcC,sBAAA;IAFAC,EAAE;MAAAC,IAAA;MAAAC,MAAA;QAAAC,SAAA,EAAiCC,IAAA,CAAAC;MAAI;IAAA;;sBACrD,MAAyD,CAAzDC,mBAAA,CAAyD,OAAzDC,UAAyD,EAA7B,QAAM,GAAAC,gBAAA,CAAGJ,IAAA,CAAAC,IAAI,CAACI,MAAM,iB;;;6BAEhDC,mBAAA,qGAAwG,EACxGA,mBAAA,kGAAmG,EACpGA,mBAAA,yJAC6F,EAC5FA,mBAAA,iGAAkG,EACtGA,mBAAA,8FAAiG,EACjGA,mBAAA,oFAAqF,G,kBACnFd,mBAAA,CAKIe,SAAA,QAAAC,WAAA,CAJgBR,IAAA,CAAAS,QAAQ,EAAnBC,OAAO;yBADhBC,YAAA,CAKIC,uBAAA;MAHDC,GAAG,EAAEH,OAAO,CAACI,OAAO;MACpBC,YAAY,EAAEL,OAAO;MACrBM,WAAS,EAAEC,QAAA,CAAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}